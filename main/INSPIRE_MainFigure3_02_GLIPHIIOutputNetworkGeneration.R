### This script is the network analysis pipeline for analysing GLIPHII output results.
### The input file for this pipeline is the raw CSV file generated by running the GLIPHII algorithm.
### ----------------------------------------------------------------------------------------

library(tidyverse)
library(igraph)
library(graphlayouts)

data_path <- "https://raw.githubusercontent.com/pughlab/INSPIRE_TCR/main/Data"

### ---------------------------------------------------------------------------------------------------------
### Reading the GLIPHII output data for network generation: -------------------------------------------------
GliphOutput_fname <- "INSPIRE_Tumour_GLIPHIIOutput.csv"
gliph_data <- readr::read_csv(file.path(data_path , GliphOutput_fname ))%>%
        select(
                type , TcRb , V ,
                pattern , Sample ) %>%
        # This step groups all the TRB CDR3s that have been assigned to similar specificity signatures together.
        group_by(type)%>% 
        
        # Since Patient-derived and external TRB CDR3s were pooled together, 
        # the TRB CDR3s with similar GLIPHII-defined specificity signatures
        # might 1) all come from external TRB CDR3s, 2) all come from patient-derived TRB CDR3s
        # or 3) come from both external and patient-derived TRB CDR3s. Since our analysis focuses
        # only on patient-derived specificity signatures we only keep groups 2 and 3 and remove
        # specificity signatures of group 1:
        
        filter( any (str_detect(pattern = "INSPIRE" , Sample))) %>%
        ungroup() %>%
        
        # Here we generate columsn that will be the node features of the final network:
        
        mutate(
                Source = unlist(
                        sapply(
                                strsplit(Sample, split = ":", fixed = TRUE), 
                                function(x) x[[1]][1], simplify=FALSE)) ,
                
                Patient_id = ifelse(grepl ("INSPIRE" , Sample ) ,
                                    str_extract(Sample, "(?<=:).*?(?=_)"),
                                    "TBD"),
                
                RECIST = ifelse(grepl ("INSPIRE" , Sample ) ,
                                unlist (sapply(strsplit(Sample, split = "_", fixed = TRUE), 
                                               function(x) x[4][1], 
                                               simplify=FALSE)),
                                "TBD"),
                
                Cycle = ifelse(grepl ("INSPIRE" , Sample ) ,
                               unlist (sapply(strsplit(Sample, split = "_", fixed = TRUE), 
                                              function(x) x[2][1], 
                                              simplify=FALSE)),
                               "TBD"),
                
                COHORT = ifelse(grepl ("INSPIRE" , Sample ) ,
                                unlist (sapply(strsplit(Sample, split = "_", fixed = TRUE), 
                                               function(x) x[3][1], 
                                               simplify=FALSE)),
                                "TBD"),
                
                Node = stringr::str_c(TcRb , "_" , Sample)) 


### ---------------------------------------------------------------------------------------------------------
### Defining the colors for external and patient-derived nodes and adding them to the GLIPHII dataframe: ----
color_shape_pallette <- data.frame(
        Paretnt_node = c(
                "MDavis" , "HomoSapiens" , 
                "EBV" ,  "CMV" ,
                "MCPyV" , "HCV" , "Influenza" , 
                "HPV" ,  "M.tuberculosis" , 
                "CEF"  ,   "S-pneumoniae" , 
                "YFV" , "HTLV" ,
                "SCCHN" , "TNBC" , "HGSOC" , "MM" , "MST") ,
        
        Node_color = c(
                "#CDEDFA" , #"MDavis" , 
                "#FF9F01" , #"HomoSapiens" , 
                "#AC261B" , #"EBV" ,  
                "#266D1F" , #"CMV" ,
                "#BAC70D" , #"MCPyV" , 
                "#FFDF01" , #"HCV" , 
                "#0C99BA" , #"Influenza" , 
                "#1A578F" , #"HPV" ,  
                "#FFC86D" , #"M.tuberculosis" , 
                "#C1A132" , #"CEF"  ,   
                "#D07F89" , #"S-pneumoniae"  ,
                "#F3A3B5" , #"YFV" ,
                "#6BB8B3" , #"HTLV"   
                "#255669" , "#617A32" , "#E06C00" , "#FFB417" , "#A0001D" #https://www.schemecolor.com/autumn-blaze.php
        ) )



conditions <- case_when(
        gliph_data$Source %in% color_shape_pallette$Paretnt_node ~ 
                color_shape_pallette$Node_color[match(gliph_data$Source, 
                                                      color_shape_pallette$Paretnt_node)],
        
        gliph_data$Source == "INSPIRE" & gliph_data$COHORT %in% c("SCCHN", "TNBC", "HGSOC", "MM", "MST") ~
                color_shape_pallette$Node_color[match(gliph_data$COHORT, 
                                                      color_shape_pallette$Paretnt_node)],
        TRUE ~ NA_character_ )


gliph_data <- gliph_data %>%
        mutate(colors = conditions)


### ---------------------------------------------------------------------------------------------------------
### Raw network generation: ---------------------------------------------------------------------------------
# Edges are defined as GLIPH-II identified global and local specificity signatures (denoted as ‘type’ in GLIPHII outputs):

specificity_signatures <- unique(gliph_data$type)
n_count <- 1
for (sig in specificity_signatures) {
        
        cdr3s <- gliph_data$Node [gliph_data$type == sig]
        if (length(cdr3s) > 1) {
                
                if (n_count == 1) {
                        
                        EDGES <- data.frame (t (combn(cdr3s , 2 , simplify = TRUE)))
                        
                        n_count <- n_count + 1
                }
                else {
                        
                        edges <- data.frame (t (combn(cdr3s , 2 , simplify = TRUE)))
                        EDGES <- bind_rows(EDGES , edges)
                }
                
        }
        
}

network <- graph_from_data_frame(d = EDGES , 
                                 vertices = unique(gliph_data %>% 
                                                           group_by(Node) %>%
                                                           mutate(type = paste(sort (unique (type) ) , collapse = ",")) %>%
                                                           unique() %>% 
                                                           dplyr::select(Node , 
                                                                         Source , 
                                                                         Patient_id ,
                                                                         Cycle ,
                                                                         COHORT ,
                                                                         RECIST ,
                                                                         TcRb ,
                                                                         V ,
                                                                         type ,
                                                                         colors)) ,
                                 directed = FALSE)

### Some quick initial network statistics:
### Network stats:
igraph::count_components(network)

range((igraph::components(network))$csize)

#Total number of patient-derived CDR3s used in specificity signature identification: 
length(V(network) [V(network)$Source == "INSPIRE"])


### ---------------------------------------------------------------------------------------------------------
### Network trimming via clique identification: -------------------------------------------------------------
### After constructing the networks, filtrations are required to withdraw loosely connected nodes 
### to increase the precision of downstream specificity annotations.
### A clique is a complete subgraph within a larger graph, 
### where every node is directly connected to every other node in that subset. 
### All nodes that do not form a clique with size four are excluded from further analysis. 

#Removing multi-edges
network <- simplify(network)
#count_components(network)

MaxClique_collection <- max_cliques(network, 
                                    min = 4, 
                                    max = NULL)


network <- induced_subgraph(network, 
                            unlist(MaxClique_collection))


### Some quick initial network statistics:
igraph::count_components(network)

range((igraph::components(network))$csize)

#Total number of patient-derived CDR3s used in specificity signature identification: 
length(V(network) [V(network)$Source == "INSPIRE"])



### ---------------------------------------------------------------------------------------------------------
### Community detection for specificity annotation: ---------------------------------------------------------

communities_leiden <- igraph::cluster_leiden(network, 
                                             objective_function = "CPM",
                                             resolution_parameter = 0.1 ,
                                             n_iterations = 10000,
                                             beta = 0.01)

# Number of communities detected:
length (unique (communities_leiden$membership))


#Adding the community id of each node to the network as a node attribute:
network <- set_vertex_attr(network, 
                           name = "LeidenCommunity", 
                           value = communities_leiden$membership)


# Saving the communities for possiblefuture use:
# saveRDS(communities_leiden,
#         file.path(gliph_path ,
#                   "Communities" ,
#                   "GLIPHII_Tumour_LeidenCommunities.rds") )

### ---------------------------------------------------------------------------------------------------------
### Fine tuning the communities: ----------------------------------------------------------------------------

#Identifying the largest clique in each community:
largest_cliques_list <- c()


for (community_id in unique(communities_leiden$membership)) {
        subgraph <- igraph::subgraph(
                network ,
                which(V(network)$LeidenCommunity == community_id))
        
        if (clique_num (subgraph) > 4) {
                
                largest_cliques_list <- append(largest_cliques_list , 
                                               unique (names(unlist(largest_cliques(subgraph)))) )
        }
        rm (subgraph)
}


trimmedNetwork <- delete_vertices(network, 
                                  setdiff(V(network)$name , largest_cliques_list))



### After we trim the network, some of the communities might only contain external
### TRB CDR3s. Therefore, we need to drop those communities.
### We loop through the communities and count the number of INSPIRE-derived nodes:

GLIPHII_Community_Source <- as.data.frame(table(V(trimmedNetwork)$LeidenCommunity)) %>%
        set_names(c("Community_id", "Community_size")) %>%
        mutate(
                NumberOf_PatientDerived_Nodes = NA )

for (n in c(1:nrow(GLIPHII_Community_Source))) {
        
        community_id <- GLIPHII_Community_Source$Community_id [n]
        
        nt <- igraph::subgraph(
                trimmedNetwork ,
                which(V(trimmedNetwork)$LeidenCommunity == community_id ))
        
        GLIPHII_Community_Source$NumberOf_PatientDerived_Nodes [n] <- length(V(nt)$name [V(nt)$Source == "INSPIRE"])
        
        
        rm (community_id , nt)
        
}




CommunityIDs_Passed <- ( GLIPHII_Community_Source %>%
                                 filter(NumberOf_PatientDerived_Nodes > 0))$Community_id

### We remove all the communities where INSPIRE-derived TRB CDR3s were missing:
trimmedNetwork_ContainsPatientNodes <- delete_vertices(trimmedNetwork, 
                                                       setdiff(V(trimmedNetwork)$name , 
                                                               V(trimmedNetwork)$name [V(trimmedNetwork)$LeidenCommunity %in% CommunityIDs_Passed]))


### The final network is generated and we can proceed to save it:
# saveRDS(trimmedNetwork_ContainsPatientNodes,
#         file.path(network_path ,
#                   "INSPIRE_Tumour_GLIPHIINetwork.rds") )
